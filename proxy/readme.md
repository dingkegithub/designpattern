>
>
>

<h2 id='1'> 1. 代理 </h2>

&ensp;&ensp;&ensp;&ensp;代理不修改被代理对象，只是给被代理类附加额外功能<br/>

<h3 id='1.1'> 1.1. 组合实现 </h3>

- 场景

	- 被代理类含有接口
	- 被代理类没有接口，但是自己开发或可控，此时可以添加接口


- 实现

    - 实现原始类的接口，即和原始类一样遵循相同的接口

    - 组合被代理对象

- 代码

```
//
// 接口
//
type Db interface {
    Create()
}

//
// 被代理类
//
type Mysql struct {
}
func (m Mysql) Create() {...}


//
// 数据库代理
//
type DbProxy struct {
    db DB // 组合
}

func (m DbProxy) Create() {
       // before todo
       m.db.Create()
       // after todo
}
```


<h3 id='1.2'> 1.2. 继承实现 </h3>

- 场景

	- 被代理类没有接口，且是第三方库


- 实现

    - 继承

    - 重写代理类的方法，并在内部调用继承的方法



<h2 id='2'> 2. 代理模式应用场景 </h2>

- 业务系统的非功能性需求开发

&ensp;&ensp;&ensp;&ensp;代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发

- RPC

&ensp;&ensp;&ensp;&ensp;实际上，RPC 框架也可以看作一种代理模式,通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。

- 缓存

&ensp;&ensp;&ensp;&ensp;假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？<br/>
&ensp;&ensp;&ensp;&ensp;给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。


<h2 id='3'> 3. 代理模式模板 </h2>

```
type IA interface {
    F()
}

// 被代理类
type A struct {
}

func (a *A) F() {
}

// 代理类
type AProxy struct {
    a IA
}

func NewAProxy(a IA) IA {
    return &AProxy {
        a: a,
    }
}

func (a *AProxy) F() {
    // 添加额外功能
    a.a.F()
}
```
